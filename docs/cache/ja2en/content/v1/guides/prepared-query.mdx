---
title: Pre-Prepared Queries
---

## Basic Usage

Here is a basic example of how to use pre-prepared queries:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";

const CreateUserQuery = surql`CREATE ONLY user:foo CONTENT { age: 42 };`
  .returns<[{ id: Thing<"user">, age: number }]>();

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery);
//    ^? const results: [{ id: Thing<"user">, age: number }]

await db.disconnect();
```

Preparing queries beforehand enables type inference. However, you need to manually set the inferred type.

## Validating Query Results

Queries become more robust by providing a validator for the query results as an argument to `.returns`. The following example uses zod to validate whether the query result is as intended:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";
import { z } from "zod";

const isUserTable = (id: Thing): id is Thing<"user"> => id.tb === "user";

const CreatedUserSchema = z.tuple([
  z.object({
    id: z.instanceof(Thing).refine(isUserTable),
    age: z.number(),
  }),
]);

const CreateUserQuery = surql`CREATE ONLY user:bar CONTENT { age: 42 };`
  .returns(CreatedUserSchema.parse.bind(CreatedUserSchema));

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery);
//    ^? const results: [{ id: Thing<"user">, age: number }]

await db.disconnect();
```

You are not limited to zod, and can use valibot or any general purpose functions to validate the response.

## Embedding Variables into Queries

`surql` allows you to visually embed values into your queries using template literals:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";

const USERNAME = "baz";
const USER_AGE = 42;

const CreateUserQuery = surql`
  CREATE ONLY type::thing('user', ${USERNAME}) CONTENT { age: ${USER_AGE} };`
  .returns<[{ id: Thing<"user">; age: number }]>();

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery);
//    ^? const results: [{ id: Thing<"user">, age: number }]

await db.disconnect();
```

The parameters sent in the RPC request for the above example are as follows:

```text
CREATE ONLY type::thing('user', $_jst_0) CONTENT { age: $_jst_1 };
```

```ts
{
  _jst_0: "baz",
  _jst_1: 42
}
```

## Defining Arguments for Queries

Use `surql.slot` to define arguments for pre-defined queries:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";
import { z } from "zod";

const isUserTable = (id: Thing): id is Thing<"user"> => id.tb === "user";

const UserIdSchema = z.instanceof(Thing).refine(isUserTable);

const UserIdSlot = surql.slot("id")
  .type(UserIdSchema.parse.bind(UserIdSchema));

const UserAgeSlot = surql.slot("age", 42);

const CreateUserQuery = surql`
  CREATE ONLY ${UserIdSlot} CONTENT { age: ${UserAgeSlot} };`
  .returns<[{ id: Thing<"user">; age: number }]>();

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery, {
  id: new Thing("user", "tai-kun"),
});

await db.disconnect();
```

Slots always require a variable name. The `.type()` method imposes type-level constraints on the variable. Similar to `.returns()`, you can pass a function that validates the value to `.type()`. In the example above, the slot with the variable name `id` must be a record ID where the table name is `"user"`.

A slot's argument can include a default value after the variable name. This default value is used when the variable name for the slot is omitted at runtime. In the example above, the slot with the variable name `age` has a default value of `42`.

Besides `.type()`, slots also have `.rename()`, `.default()`, `.optional()`, and `.required()`.

If a pre-defined query contains a slot whose variable must be specified at runtime, the query will be rejected with a `SurrealTypeError` at runtime if it's not specified. If it's correctly type-inferred by TypeScript, you will see the error at the type level without running the query. For example, if you omit the required variable and run type checking with `tsc`, you will see an error:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";

const UserIdSlot = surql.slot("id")
  .type<Thing<"user">>();

const UserAgeSlot = surql.slot("age", 42);

const CreateUserQuery = surql`
  CREATE ONLY ${UserIdSlot} CONTENT { age: ${UserAgeSlot} };`
  .returns<[{ id: Thing<"user">, age: number }]>()

const db = new Surreal();
await db.connect("ws://localhost:8000");

const results = await db.query(CreateUserQuery, {
  // id: new Thing("user", "tai-kun"),
});

await db.disconnect();
```

`npx tsc --noEmit`:

![tsc](./tsc.png)
