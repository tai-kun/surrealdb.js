---
title: Prepared Queries
slug: en/v2/guides/prepared-query
---

## Basic Usage

The following is a basic example of using a prepared query:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";

const CreateUserQuery = surql`CREATE ONLY user:foo CONTENT { age: 42 };`
  .as<[{ id: Thing<"user">, age: number }]>();

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery);
//    ^? const results: [{ id: Thing<"user">, age: number }]

await db.close();
```

Preparing a query enables type inference, but the inferred type needs to be set manually.

## Verifying Query Results

Queries become more secure when a validator for query results is passed as an argument to `.as`. The following example uses zod to verify whether query results are as intended:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";
import { z } from "zod";

const isUserTable = (id: Thing): id is Thing<"user"> => id.tb === "user";

const CreatedUserSchema = z.tuple([
  z.object({
    id: z.instanceof(Thing).refine(isUserTable),
    age: z.number(),
  }),
]);

const CreateUserQuery = surql`CREATE ONLY user:bar CONTENT { age: 42 };`
  .as(CreatedUserSchema.parse.bind(CreatedUserSchema));

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery);
//    ^? const results: [{ id: Thing<"user">, age: number }]

await db.close();
```

It's not necessary to depend on zod, and response verification can be performed using valibot or a generic function.

## Embedding Values into Queries

`surql` allows you to write queries using template literals, enabling visual embedding of values:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";

const USERNAME = "baz";
const USER_AGE = 42;

const CreateUserQuery = surql`
  CREATE ONLY type::thing('user', ${USERNAME}) CONTENT { age: ${USER_AGE} };`
  .as<[{ id: Thing<"user">; age: number }]>();

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery);
//    ^? const results: [{ id: Thing<"user">, age: number }]

await db.close();
```

The parameters of the RPC request sent in the above example are as follows:

```text
CREATE ONLY type::thing('user', $_jst_0) CONTENT { age: $_jst_1 };
```

```ts
{
  _jst_0: "baz",
  _jst_1: 42
}
```

## Defining Arguments in Queries

To define arguments for a prepared query, use `surql.slot`:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";
import { z } from "zod";

const isUserTable = (id: Thing): id is Thing<"user"> => id.tb === "user";

const UserIdSchema = z.instanceof(Thing).refine(isUserTable);

const UserIdSlot = surql.slot("id")
  .as(UserIdSchema.parse.bind(UserIdSchema));

const UserAgeSlot = surql.slot("age", 42);

const CreateUserQuery = surql`
  CREATE ONLY ${UserIdSlot} CONTENT { age: ${UserAgeSlot} };`
  .as<[{ id: Thing<"user">; age: number }]>();

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery, {
  id: new Thing("user", "tai-kun"),
});

await db.close();
```

Slots always require a variable name. You can set type-level constraints on variables using the `.as()` method. Similarly to `.as()`, a function that verifies the value can be passed as an argument to `.as()`. In the above example, the slot with the variable name `id` must be a record ID with the table name `"user"`.

Slot arguments can be set by following the variable name with a default value. This default value is used if the slot's variable name is omitted at runtime. In the above example, the slot with the variable name `age` has a default value of `42`.

Slots also have methods like `.rename()`, `.default()`, `.optional()`, and `.required()` available.

If a prepared query includes a slot whose variable must be specified at runtime, the query will be rejected at runtime with a `SurrealTypeError` if it is unspecified. If type inference is done correctly in TypeScript, an error will appear at the type level without having to run it. For example, if you omit the required variable and perform type checking with `tsc`, an error will occur as follows:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";

const UserIdSlot = surql.slot("id").as<Thing<"user">>();

const UserAgeSlot = surql.slot("age", 42);

const CreateUserQuery = surql`
  CREATE ONLY ${UserIdSlot} CONTENT { age: ${UserAgeSlot} };`
  .as<[{ id: Thing<"user">, age: number }]>()

const db = new Surreal();
await db.connect("ws://localhost:8000");

const results = await db.query(CreateUserQuery, {
  // id: new Thing("user", "tai-kun"),
});

await db.close();
```

`npx tsc --noEmit`:

![tsc](./tsc.png)
