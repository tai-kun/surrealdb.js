---
title: Prepared Queries
slug: en/v1/guides/prepared-query
---

## Basic Usage

The following is a basic example of using prepared queries:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";

const CreateUserQuery = surql`CREATE ONLY user:foo CONTENT { age: 42 };`
  .returns<[{ id: Thing<"user">, age: number }]>();

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery);
//    ^? const results: [{ id: Thing<"user">, age: number }]

await db.disconnect();
```

Preparing queries enables type inference. However, the inferred type must be manually set.

## Validating Query Results

Making queries safer by passing a validator for the query result to `.returns`. The following example uses zod to validate whether the query results are as intended:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";
import { z } from "zod";

const isUserTable = (id: Thing): id is Thing<"user"> => id.tb === "user";

const CreatedUserSchema = z.tuple([
  z.object({
    id: z.instanceof(Thing).refine(isUserTable),
    age: z.number(),
  }),
]);

const CreateUserQuery = surql`CREATE ONLY user:bar CONTENT { age: 42 };`
  .returns(CreatedUserSchema.parse.bind(CreatedUserSchema));

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery);
//    ^? const results: [{ id: Thing<"user">, age: number }]

await db.disconnect();
```

There is no dependency on zod, so you can use valibot or a general-purpose function to validate the response.

## Embedding Variables in Queries

`surql` allows you to write queries in template literals, enabling you to visually embed values:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";

const USERNAME = "baz";
const USER_AGE = 42;

const CreateUserQuery = surql`
  CREATE ONLY type::thing('user', ${USERNAME}) CONTENT { age: ${USER_AGE} };`
  .returns<[{ id: Thing<"user">; age: number }]>();

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery);
//    ^? const results: [{ id: Thing<"user">, age: number }]

await db.disconnect();
```

The parameters of the RPC request sent in the above example are:

```text
CREATE ONLY type::thing('user', $_jst_0) CONTENT { age: $_jst_1 };
```

```ts
{
  _jst_0: "baz",
  _jst_1: 42
}
```

## Defining Arguments in Queries

To define arguments for a prepared query, use `surql.slot`:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";
import { z } from "zod";

const isUserTable = (id: Thing): id is Thing<"user"> => id.tb === "user";

const UserIdSchema = z.instanceof(Thing).refine(isUserTable);

const UserIdSlot = surql.slot("id")
  .type(UserIdSchema.parse.bind(UserIdSchema));

const UserAgeSlot = surql.slot("age", 42);

const CreateUserQuery = surql`
  CREATE ONLY ${UserIdSlot} CONTENT { age: ${UserAgeSlot} };`
  .returns<[{ id: Thing<"user">; age: number }]>();

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery, {
  id: new Thing("user", "tai-kun"),
});

await db.disconnect();
```

Slots require a variable name. You can use the `.type()` method to restrict the variable at the type level. Similar to `.returns()`, you can pass a function that validates the value to the `.type()` argument. In the above example, the slot with the variable name `id` must be a record ID whose table name is `"user"`.

The slot's argument can be set with a default value following the variable name. This default value is used if the slot's variable name is omitted at runtime. In the above example, the slot with the variable name `age` has a default value of `42`.

Besides `.type()`, `.rename()`, `.default()`, `.optional()`, and `.required()` are available for slots.

If a prepared query includes a slot that requires the specification of a variable at runtime, the query will be rejected at runtime with `SurrealTypeError` if it is unspecified. If type inference is correct in TypeScript, an error will be displayed at the type level without execution. For example, if you omit a required variable and run type checking with `tsc`, you will get an error as follows:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";

const UserIdSlot = surql.slot("id")
  .type<Thing<"user">>();

const UserAgeSlot = surql.slot("age", 42);

const CreateUserQuery = surql`
  CREATE ONLY ${UserIdSlot} CONTENT { age: ${UserAgeSlot} };`
  .returns<[{ id: Thing<"user">, age: number }]>()

const db = new Surreal();
await db.connect("ws://localhost:8000");

const results = await db.query(CreateUserQuery, {
  // id: new Thing("user", "tai-kun"),
});

await db.disconnect();
```

`npx tsc --noEmit`:

![tsc](./tsc.png)
