---
title: Prepared Queries
slug: en/v2/guides/prepared-query
---

## Basic Usage

Here is a basic example of using a prepared query:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";

const CreateUserQuery = surql`CREATE ONLY user:foo CONTENT { age: 42 };`
  .as<[{ id: Thing<"user">, age: number }]>();

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery);
//    ^? const results: [{ id: Thing<"user">, age: number }]

await db.close();
```

Preparing queries enables type inference. However, you need to manually set the inferred type.

## Validating Query Results

Queries can be made safer by passing a validator for the query result in the `.as` argument. The following example uses zod to validate whether the query results are the intended value:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";
import { z } from "zod";

const isUserTable = (id: Thing): id is Thing<"user"> => id.tb === "user";

const CreatedUserSchema = z.tuple([
  z.object({
    id: z.instanceof(Thing).refine(isUserTable),
    age: z.number(),
  }),
]);

const CreateUserQuery = surql`CREATE ONLY user:bar CONTENT { age: 42 };`
  .as(CreatedUserSchema.parse.bind(CreatedUserSchema));

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery);
//    ^? const results: [{ id: Thing<"user">, age: number }]

await db.close();
```

This is not dependent on zod, so you can use valibot or generic functions to validate the response.

## Embedding Variables in Queries

`surql` can describe queries with template strings, which enables you to visually embed values:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";

const USERNAME = "baz";
const USER_AGE = 42;

const CreateUserQuery = surql`
  CREATE ONLY type::thing('user', ${USERNAME}) CONTENT { age: ${USER_AGE} };`
  .as<[{ id: Thing<"user">; age: number }]>();

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery);
//    ^? const results: [{ id: Thing<"user">, age: number }]

await db.close();
```

The following are the parameters of the RPC request sent in the above example:

```text
CREATE ONLY type::thing('user', $_jst_0) CONTENT { age: $_jst_1 };
```

```ts
{
  _jst_0: "baz",
  _jst_1: 42
}
```

## Defining Arguments in Queries

Use `surql.slot` to define arguments for prepared queries:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";
import { z } from "zod";

const isUserTable = (id: Thing): id is Thing<"user"> => id.tb === "user";

const UserIdSchema = z.instanceof(Thing).refine(isUserTable);

const UserIdSlot = surql.slot("id")
  .as(UserIdSchema.parse.bind(UserIdSchema));

const UserAgeSlot = surql.slot("age", 42);

const CreateUserQuery = surql`
  CREATE ONLY ${UserIdSlot} CONTENT { age: ${UserAgeSlot} };`
  .as<[{ id: Thing<"user">; age: number }]>();

const db = new Surreal();
await db.connect(`ws://localhost:8000`);
await db.signin({ user: "root", pass: "root" });
await db.use("example", "example");

const results = await db.query(CreateUserQuery, {
  id: new Thing("user", "tai-kun"),
});

await db.close();
```

Slots must have variable names. You can constrain variables at the type level with the `.as()` method. Similar to `.as()`, you can pass a function to validate the value in the `.as()` argument. In the example above, the slot with the variable name `id` must be a record ID whose table name is `"user"`.

Slots can be assigned a default value after the variable name. This default value is used if the variable name for the slot is omitted at runtime. In the example above, the slot with the variable name `age` is set to a default value of `42`.

In addition to `.as()`, `.rename()`, `.default()`, `.optional()`, and `.required()` are also available for slots.

If a prepared query contains a slot that requires a variable to be specified at runtime, the query will be rejected with a `SurrealTypeError` at runtime if it is not specified. If you have correct type inference in TypeScript, an error will be displayed at the type level without execution. For example, the following code will result in an error if you run `tsc` for type checking while omitting the required variable:

```ts
import { surql, Surreal, Thing } from "@tai-kun/surrealdb";

const UserIdSlot = surql.slot("id").as<Thing<"user">>();

const UserAgeSlot = surql.slot("age", 42);

const CreateUserQuery = surql`
  CREATE ONLY ${UserIdSlot} CONTENT { age: ${UserAgeSlot} };`
  .as<[{ id: Thing<"user">, age: number }]>()

const db = new Surreal();
await db.connect("ws://localhost:8000");

const results = await db.query(CreateUserQuery, {
  // id: new Thing("user", "tai-kun"),
});

await db.close();
```

`npx tsc --noEmit`:

![tsc](./tsc.png)
